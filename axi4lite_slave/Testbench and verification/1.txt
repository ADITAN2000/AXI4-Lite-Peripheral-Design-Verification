`timescale 1ns/1ps
//////////////////////////////////////////////////////////////////////////////////
// Testbench for AXI4-Lite Slave
// Verifies basic read and write operations to 4 internal registers
//////////////////////////////////////////////////////////////////////////////////

module tb_axi4lite_slave;

  // Parameters
  parameter C_S_AXI_DATA_WIDTH = 32;
  parameter C_S_AXI_ADDR_WIDTH = 4;

  // Clock & Reset
  reg clk;
  reg rstn;

  // AXI4-Lite signals
  reg  [C_S_AXI_ADDR_WIDTH-1:0] awaddr;
  reg                           awvalid;
  wire                          awready;

  reg  [C_S_AXI_DATA_WIDTH-1:0] wdata;
  reg  [(C_S_AXI_DATA_WIDTH/8)-1:0] wstrb;
  reg                           wvalid;
  wire                          wready;

  wire [1:0]                    bresp;
  wire                          bvalid;
  reg                           bready;

  reg  [C_S_AXI_ADDR_WIDTH-1:0] araddr;
  reg                           arvalid;
  wire                          arready;

  wire [C_S_AXI_DATA_WIDTH-1:0] rdata;
  wire [1:0]                    rresp;
  wire                          rvalid;
  reg                           rready;

  // DUT Instance
  axi4lite_slave DUT (
    .S_AXI_ACLK   (clk),
    .S_AXI_ARESETN(rstn),
    .S_AXI_AWADDR (awaddr),
    .S_AXI_AWVALID(awvalid),
    .S_AXI_AWREADY(awready),
    .S_AXI_WDATA  (wdata),
    .S_AXI_WSTRB  (wstrb),
    .S_AXI_WVALID (wvalid),
    .S_AXI_WREADY (wready),
    .S_AXI_BRESP  (bresp),
    .S_AXI_BVALID (bvalid),
    .S_AXI_BREADY (bready),
    .S_AXI_ARADDR (araddr),
    .S_AXI_ARVALID(arvalid),
    .S_AXI_ARREADY(arready),
    .S_AXI_RDATA  (rdata),
    .S_AXI_RRESP  (rresp),
    .S_AXI_RVALID (rvalid),
    .S_AXI_RREADY (rready)
  );

  // Clock generation (100 MHz)
  always #5 clk = ~clk;

  // Write Task
  task axi_write(input [3:0] addr, input [31:0] data);
  begin
    @(posedge clk);
    awaddr  <= addr;
    awvalid <= 1;
    wdata   <= data;
    wstrb   <= 4'b1111;
    wvalid  <= 1;
    bready  <= 1;

    wait(awready && wready);
    @(posedge clk);
    awvalid <= 0;
    wvalid  <= 0;

    wait(bvalid);
    @(posedge clk);
    bready <= 0;
  end
  endtask

  // Read Task
  task axi_read(input [3:0] addr, output [31:0] data_out);
  begin
    @(posedge clk);
    araddr  <= addr;
    arvalid <= 1;
    rready  <= 1;

    wait(arready);
    @(posedge clk);
    arvalid <= 0;

    wait(rvalid);
    data_out = rdata;
    @(posedge clk);
    rready <= 0;
  end
  endtask

  // Simulation
  reg [31:0] read_val;

  initial begin
    // Init
    clk     = 0;
    rstn    = 0;
    awaddr  = 0; awvalid = 0;
    wdata   = 0; wstrb   = 0; wvalid = 0;
    bready  = 0;
    araddr  = 0; arvalid = 0; rready = 0;

    // Release reset
    #20 rstn = 1;

    // Write to reg0
    axi_write(4'h0, 32'hDEADBEEF);
    // Write to reg1
    axi_write(4'h4, 32'h12345678);

    // Read reg0
    axi_read(4'h0, read_val);
    if (read_val == 32'hDEADBEEF)
      $display("PASS: Read reg0 = %h", read_val);
    else
      $display("FAIL: Expected DEADBEEF, got %h", read_val);

    // Read reg1
    axi_read(4'h4, read_val);
    if (read_val == 32'h12345678)
      $display("PASS: Read reg1 = %h", read_val);
    else
      $display("FAIL: Expected 12345678, got %h", read_val);

    #50;
    $finish;
  end

endmodule
