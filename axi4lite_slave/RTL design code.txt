// rtl/axi4lite_slave.sv
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Simple AXI4-Lite Slave (4 x 32-bit registers)
// - Supports byte enables (WSTRB)
// - Word-aligned addresses required (addr[1:0] == 2'b00)
// - BRESP/RRESP = OKAY(2'b00) or SLVERR(2'b10) on invalid access
//////////////////////////////////////////////////////////////////////////////////

module axi4lite_slave #(
    parameter integer C_S_AXI_DATA_WIDTH = 32,
    parameter integer C_S_AXI_ADDR_WIDTH = 4   // addr width in bits (enough for 16 bytes => 4)
)(
    input  wire                               S_AXI_ACLK,
    input  wire                               S_AXI_ARESETN,

    // Write address channel
    input  wire [C_S_AXI_ADDR_WIDTH-1:0]      S_AXI_AWADDR,
    input  wire                               S_AXI_AWVALID,
    output reg                                S_AXI_AWREADY,

    // Write data channel
    input  wire [C_S_AXI_DATA_WIDTH-1:0]      S_AXI_WDATA,
    input  wire [(C_S_AXI_DATA_WIDTH/8)-1:0]  S_AXI_WSTRB,
    input  wire                               S_AXI_WVALID,
    output reg                                S_AXI_WREADY,

    // Write response channel
    output reg [1:0]                          S_AXI_BRESP,
    output reg                                S_AXI_BVALID,
    input  wire                               S_AXI_BREADY,

    // Read address channel
    input  wire [C_S_AXI_ADDR_WIDTH-1:0]      S_AXI_ARADDR,
    input  wire                               S_AXI_ARVALID,
    output reg                                S_AXI_ARREADY,

    // Read data channel
    output reg [C_S_AXI_DATA_WIDTH-1:0]       S_AXI_RDATA,
    output reg [1:0]                          S_AXI_RRESP,
    output reg                                S_AXI_RVALID,
    input  wire                               S_AXI_RREADY
);

    // Local params
    localparam [1:0] AXI_OKAY  = 2'b00;
    localparam [1:0] AXI_SLVERR = 2'b10;

    // Register file: 4 x DATA_WIDTH
    reg [C_S_AXI_DATA_WIDTH-1:0] regs [0:3];

    // Internal address latches (captured on handshake)
    reg [C_S_AXI_ADDR_WIDTH-1:0] awaddr_q;
    reg [C_S_AXI_ADDR_WIDTH-1:0] araddr_q;

    // Handshake strobes
    wire aw_hs = S_AXI_AWVALID & S_AXI_AWREADY;
    wire w_hs  = S_AXI_WVALID  & S_AXI_WREADY;
    wire ar_hs = S_AXI_ARVALID & S_AXI_ARREADY;

    // Reset / init
    integer i;
    always_ff @(posedge S_AXI_ACLK or negedge S_AXI_ARESETN) begin
        if (!S_AXI_ARESETN) begin
            S_AXI_AWREADY <= 1'b0;
            S_AXI_WREADY  <= 1'b0;
            S_AXI_BVALID  <= 1'b0;
            S_AXI_BRESP   <= AXI_OKAY;
            S_AXI_ARREADY <= 1'b0;
            S_AXI_RVALID  <= 1'b0;
            S_AXI_RRESP   <= AXI_OKAY;
            S_AXI_RDATA   <= {C_S_AXI_DATA_WIDTH{1'b0}};
            awaddr_q      <= {C_S_AXI_ADDR_WIDTH{1'b0}};
            araddr_q      <= {C_S_AXI_ADDR_WIDTH{1'b0}};
            for (i = 0; i < 4; i = i + 1) regs[i] <= {C_S_AXI_DATA_WIDTH{1'b0}};
        end else begin
            // ----------------------
            // WRITE ADDRESS CHANNEL
            // ----------------------
            // Accept AW when AWVALID asserted and we are not already asserting AWREADY
            if (!S_AXI_AWREADY && S_AXI_AWVALID) begin
                S_AXI_AWREADY <= 1'b1;
                awaddr_q <= S_AXI_AWADDR;
            end else begin
                S_AXI_AWREADY <= 1'b0;
            end

            // ----------------------
            // WRITE DATA CHANNEL
            // ----------------------
            if (!S_AXI_WREADY && S_AXI_WVALID) begin
                S_AXI_WREADY <= 1'b1;
            end else begin
                S_AXI_WREADY <= 1'b0;
            end

            // If both address/data have been/are accepted, perform write and issue response
            if (!S_AXI_BVALID && ( (aw_hs && w_hs) || (S_AXI_AWVALID && S_AXI_WVALID && S_AXI_AWREADY && S_AXI_WREADY) )) begin
                // check alignment & address range
                if (awaddr_q[1:0] == 2'b00 && awaddr_q[C_S_AXI_ADDR_WIDTH-1:2] <= 2) begin
                    // determine register index
                    int idx = awaddr_q[3:2];
                    // byte-enable write using WSTRB
                    for (int byte = 0; byte < (C_S_AXI_DATA_WIDTH/8); byte = byte + 1) begin
                        if (S_AXI_WSTRB[byte]) begin
                            regs[idx][8*byte +: 8] <= S_AXI_WDATA[8*byte +: 8];
                        end
                    end
                    S_AXI_BRESP <= AXI_OKAY;
                end else begin
                    S_AXI_BRESP <= AXI_SLVERR;
                end
                S_AXI_BVALID <= 1'b1;
            end else if (S_AXI_BVALID && S_AXI_BREADY) begin
                S_AXI_BVALID <= 1'b0;
            end

            // ----------------------
            // READ ADDRESS CHANNEL
            // ----------------------
            if (!S_AXI_ARREADY && S_AXI_ARVALID) begin
                S_AXI_ARREADY <= 1'b1;
                araddr_q <= S_AXI_ARADDR;
            end else begin
                S_AXI_ARREADY <= 1'b0;
            end

            // ----------------------
            // READ DATA CHANNEL
            // ----------------------
            if (!S_AXI_RVALID && (ar_hs || (S_AXI_ARVALID && S_AXI_ARREADY))) begin
                // check alignment & range
                if (araddr_q[1:0] == 2'b00 && araddr_q[C_S_AXI_ADDR_WIDTH-1:2] <= 2) begin
                    S_AXI_RDATA <= regs[araddr_q[3:2]];
                    S_AXI_RRESP <= AXI_OKAY;
                end else begin
                    S_AXI_RDATA <= {C_S_AXI_DATA_WIDTH{1'b0}};
                    S_AXI_RRESP <= AXI_SLVERR;
                end
                S_AXI_RVALID <= 1'b1;
            end else if (S_AXI_RVALID && S_AXI_RREADY) begin
                S_AXI_RVALID <= 1'b0;
            end
        end
    end

endmodule
